<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>記憶の桜島</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #000;
            font-family: sans-serif;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #permission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #permission-overlay.hidden {
            display: none;
        }
        #permission-btn {
            padding: 10px 20px;
            font-size: 18px;
            background: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        #permission-text {
            color: #fff;
            margin-bottom: 30px;
            text-align: center;
            padding: 0 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        #attribution {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="permission-overlay">
        <div id="permission-text">
            歩くと、桜島は灰になり、<br>
            少し立ち止まると、灰は桜島に戻ります。<br><br>
            モーションセンサーへのアクセスを<br>許可してください
        </div>
        <button id="permission-btn">開始</button>
        <div id="attribution">※基盤地図情報数値標高モデルを加工して作成</div>
    </div>
    <canvas id="canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

        // ========================================
        // 設定：外部点群ファイルのパス
        // ========================================
        // null の場合は、デフォルトの円錐形の山を生成
        // PLYファイルを使う場合は、ファイルパスを指定
        const POINT_CLOUD_FILE = './sakurajima.ply'; // 例: './sakurajima.ply'

        // ========================================
        // グローバル変数
        // ========================================
        let scene, camera, renderer, particles, controls;
        let isWalking = false;
        let isStill = true;
        let stillTimer = 0;
        const STILL_THRESHOLD = 5000; // 5秒
        let autoRotateAngle = 0; // 自動回転用の角度
        let userInteracting = false; // ユーザー操作中フラグ
        let interactionTimeout = null; // 操作終了検出用タイマー

        // センサー関連
        let lastAccel = { x: 0, y: 0, z: 0 };
        const ACCEL_THRESHOLD = 1.0; // 歩行判定の閾値（調整可能）

        // パーティクル設定
        const originalPositions = [];
        const velocities = [];
        const particleStates = []; // 各パーティクルの状態（0: 山の一部, 1: 放出中）
        const RELEASE_RATE = 160; // 1フレームあたりランダムに放出される点の数（噴火は激しく）

        // ========================================
        // three.js初期化
        // ========================================
        function init() {
            // シーン
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // カメラ（FOVを75度に拡大してスマホで見やすく）
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(5, 3, 0);
            camera.lookAt(0, 1, 0);

            // レンダラー
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // 点群生成
            loadPointCloudFromFile(POINT_CLOUD_FILE);

            // OrbitControls（3D回転操作）
            controls = new OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = false;
            controls.minDistance = 2;
            controls.maxDistance = 25;

            // ユーザー操作開始時のイベント
            controls.addEventListener('start', function() {
                userInteracting = true;
                if (interactionTimeout) {
                    clearTimeout(interactionTimeout);
                }
            });

            // ユーザー操作終了時のイベント（2秒後に自動回転再開）
            controls.addEventListener('end', function() {
                if (interactionTimeout) {
                    clearTimeout(interactionTimeout);
                }
                interactionTimeout = setTimeout(function() {
                    userInteracting = false;
                }, 2000);
            });

            // リサイズ対応
            window.addEventListener('resize', onResize);
        }

        // ========================================
        // 外部ファイルから点群を読み込み
        // ========================================
        function loadPointCloudFromFile(filePath) {
            const loader = new PLYLoader();
            loader.load(
                filePath,
                function (geometry) {
                    // ジオメトリから位置情報を取得
                    const positions = geometry.getAttribute('position');
                    const count = positions.count;

                    // バウンディングボックスを計算して中心とスケールを取得
                    geometry.computeBoundingBox();
                    const bbox = geometry.boundingBox;
                    const center = new THREE.Vector3();
                    bbox.getCenter(center);
                    const size = new THREE.Vector3();
                    bbox.getSize(size);

                    // 点群を中心に移動してスケール調整
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4.0 / maxDim; // 高さ4に正規化（デフォルトの山と同じ）

                    // オリジナル位置を保存（中心化＆スケール済み）
                    // Z軸を高さにするため、Y軸とZ軸を入れ替え
                    for (let i = 0; i < count; i++) {
                        const x = (positions.getX(i) - center.x) * scale;
                        const y = (positions.getZ(i) - center.z) * scale; // Z→Y
                        const z = (positions.getY(i) - center.y) * scale; // Y→Z

                        positions.setXYZ(i, x, y, z);
                        originalPositions.push({ x, y, z });
                        velocities.push({ x: 0, y: 0, z: 0 });
                        particleStates.push(0);
                    }

                    positions.needsUpdate = true;

                    // バウンディングボックスを再計算
                    geometry.computeBoundingBox();

                    // マテリアル（火山灰イメージ）
                    const material = new THREE.PointsMaterial({
                        color: 0xffffff,
                        size: 0.01,
                        sizeAttenuation: true,
                        transparent: true,
                        opacity: 0.90,
                        depthWrite: false,
                        depthTest: true,
                        blending: THREE.AdditiveBlending
                    });

                    particles = new THREE.Points(geometry, material);
                    particles.frustumCulled = false; // フラスタムカリングを無効化
                    scene.add(particles);
                },
                undefined,
                function (error) {
                    console.error('Failed to load point cloud file');
                }
            );
        }

        // ========================================
        // センサー初期化
        // ========================================
        function initSensors() {
            if (typeof DeviceMotionEvent !== 'undefined') {
                window.addEventListener('devicemotion', handleMotion);
            } else {
                console.warn('DeviceMotionEvent not supported');
            }
        }

        // ========================================
        // 加速度センサー処理
        // ========================================
        function handleMotion(event) {
            if (!event.accelerationIncludingGravity) return;

            const accel = event.accelerationIncludingGravity;
            const dx = Math.abs(accel.x - lastAccel.x);
            const dy = Math.abs(accel.y - lastAccel.y);
            const dz = Math.abs(accel.z - lastAccel.z);
            const totalChange = dx + dy + dz;

            // 歩行判定
            if (totalChange > ACCEL_THRESHOLD) {
                isWalking = true;
                isStill = false;
                stillTimer = 0;
            } else {
                isWalking = false;
                stillTimer += 16; // 約60fps想定

                // 5秒以上静止したらstill状態
                if (stillTimer >= STILL_THRESHOLD) {
                    isStill = true;
                }
            }

            lastAccel = { x: accel.x, y: accel.y, z: accel.z };
        }

        // ========================================
        // パーティクル更新
        // ========================================
        function updateParticles() {
            if (!particles || !particles.geometry) return;

            const positionsAttr = particles.geometry.getAttribute('position');
            if (!positionsAttr) return;

            const positions = positionsAttr.array;
            const particleCount = originalPositions.length;

            // 歩行中：ランダムに点群を放出状態にする
            if (isWalking) {
                // 毎フレーム、ランダムに数点を放出状態に変更
                const releaseCount = Math.min(RELEASE_RATE, particleCount);
                for (let j = 0; j < releaseCount; j++) {
                    const randomIndex = Math.floor(Math.random() * particleCount);
                    if (particleStates[randomIndex] === 0) {
                        particleStates[randomIndex] = 1; // 放出状態にする

                        // 放出時の初速度を与える（噴火で上方向へ舞い上がる）
                        const vel = velocities[randomIndex];
                        const i3 = randomIndex * 3;

                        // 現在位置を取得
                        const px = positions[i3];
                        const py = positions[i3 + 1];
                        const pz = positions[i3 + 2];

                        // 上方向メインで、少し横方向にもランダムに散る（火山灰イメージ）
                        const upwardPower = 0.08 + Math.random() * 0.05; // 強めの上昇
                        vel.y = upwardPower;
                        vel.x = (Math.random() - 0.5) * 0.03; // 横方向の散り
                        vel.z = (Math.random() - 0.5) * 0.03;
                    }
                }
            } else if (isStill) {
                // 静止中：すべての点を山の一部に戻す
                for (let i = 0; i < particleCount; i++) {
                    particleStates[i] = 0;
                }
            }

            // 各パーティクルの位置更新
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const orig = originalPositions[i];
                const vel = velocities[i];
                const state = particleStates[i];

                if (state === 1) {
                    // 放出中：火山灰のように浮遊しながら横に流れる
                    // ランダムに揺らぎながら漂う
                    vel.x += (Math.random() - 0.5) * 0.002;
                    vel.y += (Math.random() - 0.5) * 0.002; // 上下にもゆらぎ
                    vel.z += (Math.random() - 0.5) * 0.002;

                    // 速度減衰（徐々に静止する）
                    vel.x *= 0.96;
                    vel.y *= 0.96;
                    vel.z *= 0.96;
                } else {
                    // 山の一部：元の位置へ戻る／維持する
                    const dx = orig.x - positions[i3];
                    const dy = orig.y - positions[i3 + 1];
                    const dz = orig.z - positions[i3 + 2];

                    vel.x = dx * 0.05;
                    vel.y = dy * 0.05;
                    vel.z = dz * 0.05;
                }

                // 位置更新
                positions[i3] += vel.x;
                positions[i3 + 1] += vel.y;
                positions[i3 + 2] += vel.z;
            }

            positionsAttr.needsUpdate = true;
        }

        // ========================================
        // アニメーションループ
        // ========================================
        function animate() {
            requestAnimationFrame(animate);

            // ユーザーが操作していない場合のみ自動回転
            if (!userInteracting) {
                autoRotateAngle += 0.002; // 回転速度
                const radius = Math.sqrt(
                    camera.position.x * camera.position.x +
                    camera.position.z * camera.position.z
                );
                camera.position.x = Math.cos(autoRotateAngle) * radius;
                camera.position.z = Math.sin(autoRotateAngle) * radius;
                camera.lookAt(0, 1, 0);
            }

            controls.update(); // OrbitControlsの更新
            updateParticles();
            renderer.render(scene, camera);
        }

        // ========================================
        // リサイズ対応
        // ========================================
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========================================
        // 許可ボタン処理
        // ========================================
        document.getElementById('permission-btn').addEventListener('click', async () => {
            // iOS 13+ のDeviceMotionEvent許可
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceMotionEvent.requestPermission();
                    if (permission === 'granted') {
                        initSensors();
                    }
                } catch (error) {
                    console.error('Permission denied', error);
                }
            } else {
                // Android等
                initSensors();
            }

            // オーバーレイを非表示
            document.getElementById('permission-overlay').classList.add('hidden');
        });

        // ========================================
        // 起動
        // ========================================
        init();
        animate();
    </script>
</body>
</html>
